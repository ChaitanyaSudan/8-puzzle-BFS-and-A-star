# 8-puzzle Problem using BFS algorithm 

import numpy as np # Used to store the digits in an array 
import time

class Node: 
    def __init__(self, node_no, data, parent, id, cost): 
        self.data = data 
        self.parent = parent 
        self.id = id 
        self.node_no = node_no
        self.cost = cost 
        
def find_index(puzzle): 
    i, j = np.where(puzzle == 0) 
    i = int(i) 
    j = int(j) 
    return i, j

def move_left(data): 
    i, j = find_index(data) 
    if j == 0: 
        return None 
    else: 
        temp_arr = np.copy(data) 
        temp = temp_arr[i, j-1] 
        temp_arr[i, j] = temp 
        temp_arr[i, j-1] = 0 
        return temp_arr
    
def move_right(data): 
    i, j = find_index(data) 
    if j == 2: 
        return None 
    else: 
        temp_arr = np.copy(data) 
        temp = temp_arr[i, j+1] 
        temp_arr[i, j] = temp 
        temp_arr[i, j+1] = 0 
        return temp_arr

def move_up(data): 
    i, j = find_index(data) 
    if i == 0: 
        return None 
    else: 
        temp_arr = np.copy(data) 
        temp = temp_arr[i-1, j] 
        temp_arr[i, j] = temp 
        temp_arr[i-1, j] = 0 
        return temp_arr
    
def move_down(data): 
    i, j = find_index(data) 
    if i == 2: 
        return None
    else:
        temp_arr = np.copy(data) 
        temp = temp_arr[i+1, j] 
        temp_arr[i, j] = temp 
        temp_arr[i+1, j] = 0 
        return temp_arr

def move_tile(action, data): 
    if action == 'up':
        return move_up(data) 
    if action == 'down': 
        return move_down(data) 
    if action == 'left': 
        return move_left(data) 
    if action == 'right': 
        return move_right(data) 
    else: 
        return None    

def print_states(list_final): # To print the final states on the console 
    count=0
    print("The Path Traversed by the BFS Algorithm is\n") 
    for l in list_final: 
        print("\nMove Made : " + str(l.id) + "\n" + "Current Configuration : " + "\n" + str(l.data) + "\t")
        count=count+1
    print("\n*******************************************************************")
    print("Number of nodes generated by the Breadth First Algorithm is "+ str(l.node_no))
    print("\n*******************************************************************")
    print("The Depth at which the solution is present is at ",count-1)
    print("\n*******************************************************************")


def path(node): # To find the path from the goal node to the starting node 
    p = [] # Empty list 
    p.append(node) 
    parent_node = node.parent 
    while parent_node is not None: 
        p.append(parent_node) 
        parent_node = parent_node.parent 
    return list(reversed(p))

def exploring_nodes(node): 
    actions = ["down", "up", "left", "right"] 
    goal_node = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 0]]) 
    node_q = [node] 
    final_nodes = [] 
    visited = [] 
    final_nodes.append(node_q[0].data.tolist()) # Only writing data of nodes in seen 
    node_counter = 0 # To define a unique ID to all the nodes formed
    while node_q: 
        current_root = node_q.pop(0) # Pop the element 0 from the list 
        if current_root.data.tolist() == goal_node.tolist(): 
            return current_root, final_nodes, visited
        for move in actions: 
            temp_data = move_tile(move, current_root.data) 
            if temp_data is not None: 
                node_counter += 1 
                child_node = Node(node_counter, np.array(temp_data), current_root, move, 0) # Create a child node
                if child_node.data.tolist() not in final_nodes: # Add the child node data in final node list
                    node_q.append(child_node) 
                    final_nodes.append(child_node.data.tolist()) 
                    visited.append(child_node) 
                    if child_node.data.tolist() == goal_node.tolist(): 
                        return child_node, final_nodes, visited 
    return None, None, None # return statement if the goal node is not reached


# Final Running of the Code
print("The Start State of 8-puzzle is\n")
print("1 2 3\n0 4 6\n7 5 8\n")
k =np.array([[1, 2, 3], [0,4,6], [7, 5, 8]])
print("The Goal State of the 8-puzzle is\n")
print("1 2 3\n4 5 6\n7 8 0")
print("\n************************************************************************")
root = Node(0, k, None, None, 0)

# BFS implementation call
goal, s, v = exploring_nodes(root)
if goal is None and s is None and v is None: 
    print("Goal State could not be reached, Sorry") 
else:  
        print_states(path(goal))

print("Time Delay of 30 Secounds has been provided for Runtime to read the Execution")
time.sleep(30)
